/// \file
/// \addtogroup Recognizer
/// @{
///
// AUTOGENERATED FILE - DO NOT MODIFY!
// This file generated by Djinni from recognizer.djinni

#pragma once

#include "bnb/types/interfaces/frame_data.hpp"
#include <bnb/utils/defs.hpp>
#include <cstdint>
#include <memory>

namespace bnb { namespace interfaces {

enum class face_search_mode;
enum class feature_id;

class BNB_EXPORT active_recognizer {
public:
    virtual ~active_recognizer() {}

    static std::shared_ptr<active_recognizer> create();

    virtual void set_features(feature_id features) = 0;

    /** sets maximum allowed face results, if face tracking feature is present */
    virtual void set_max_faces(int32_t num) = 0;

    virtual void set_offline_mode(bool on) = 0;

    /**
     * Set flag which enable NN-dependent features. True by default, if device compatible with NN player
     * When this flag is false, recognizer will skip NN-dependent features during set_features call.
     * In case when device have no NN player support (is_device_nn_compatible return false),
     * setting enable to true have no any effect
     */
    virtual void set_nn_enable(bool enable) = 0;

    virtual bool get_nn_enable() const = 0;

    /**
     * Check if device compatible with NN player.
     * This call will return correct information only after gl context will be created
     */
    virtual bool is_device_nn_compatible() = 0;

    /** Clear pipeline state and set face search mode */
    virtual void set_face_search_mode(face_search_mode mode) = 0;

    virtual void push_camera_frame(const std::shared_ptr<::bnb::interfaces::frame_data> & input_frame_data) = 0;

    virtual bool pop_frame_data(const std::shared_ptr<::bnb::interfaces::frame_data> & output_frame_data) = 0;

    /** start the thread */
    virtual void start() = 0;

    /** pause + clear */
    virtual void stop() = 0;

    /** clear input and output buffers and pipeline state */
    virtual void clear() = 0;
};

} }  // namespace bnb::interfaces
/// @}

